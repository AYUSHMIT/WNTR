import numpy as np
import matplotlib.pyplot as plt
import wntr

def fraction_delivered_metrics(results, nzd_junctions, EACH_TIME, EACH_NODE, Dstar, Pstar,adjust_demand_flag=False):
    """
    Fraction delivered volume that can be averaged over all times or nodes
    
    Parameters
    ----------
    results : pandas dataframe
        Results object from simultation
        
    EACH_TIME : bool
        Flag to determine if calculations are to be performed over each time
        step. If true, FDV calculations will be performed for each time step.
        If false, FDV calculations will be averaged over all time steps.
    
    EACH_NODE : bool
        Flag to determine if calculations are to be performed over each node. 
        If true, FDV calculations will be performed for each node.If false, FDV
        calculations will be averaged over all nodes.
        
    Pstar: scalar
        Minimum pressure threshold if the demand needs to be adjusted. 
        
        **NOTE: Pstar needs to be tested**
        
    adjust_demand_flag : bool, optional
        (default = false) Flag to determine if demand needs to be adjusted.
        This step is already accounted for if using Pyomo simulator but may
        need to be set to true if using EPANET simulator
        
        **NOTE: adjust_demand_flag needs to be tested**
        
    Returns 
    -------    
    fdv_time : dict
        fraction of delivered volume for each node and time step
        
    Notes
    -----
    Modified from Equation 2 in Ostfeld et al, Urban Water, 4, 2002
    """  

    exp_demand = results.node.loc[nzd_junctions,'expected_demand']
    act_received = results.node.loc[nzd_junctions,'demand']
        
#   Check minimum pressure
    if adjust_demand_flag == True:
        P = results.node.loc[:,'head']
        act_received = adjust_demand(act_received, P, Pstar)
    
    # FDV for all times and nodes
    if EACH_TIME==True and EACH_NODE==True:
        temp_exp_demand = exp_demand
        temp_act_received = act_received        
        
    # FDV for all nodes (averaged over all times)    
    if EACH_TIME==False and EACH_NODE==True:
        temp_exp_demand = exp_demand.sum(level=0)
        temp_act_received = act_received.sum(level=0)
        
    # FDV for all time (averaged over all nodes)        
    if EACH_TIME==True and EACH_NODE==False:
        temp_exp_demand = exp_demand.sum(level=1)
        temp_act_received = act_received.sum(level=1)
       
    # FDV for scenario (averaged over all times and nodes)   
    if EACH_TIME==False and EACH_NODE==False:
        temp_exp_demand = exp_demand.sum(0)
        temp_act_received = act_received.sum(0)
    
    # Calculate FDV    
    fdv = temp_act_received / temp_exp_demand
    
    # Replace NaNs (generated by nodes with 0 demand) 
    if EACH_TIME==True or EACH_NODE==True:
        fdv = fdv.fillna(1) 
        
    # Calculate FDD
    fdd = (fdv >= Dstar)+0 
    
    return fdv,fdd
    
def fraction_delivered_graph(fdv, fdd, EACH_TIME, EACH_NODE,wn):
    """
    Graphs the fraction delivered volume (FDV) and fraction delivered demand 
    (FDD) based on the their respective formats (i.e. if they were averaged
    over times or nodes)
    
    Parameters
    ----------
    fdv: pandas dataframe
        Calculated FDV from fraction_delivered_metrics.py

    fdd: pandas dataframe
        Calculated FDD from fraction_delivered_metrics.py
    
    EACH_TIME: bool
        Flag to determine if calculations are to be performed over each time
        step. If true, FDV calculations will be performed for each time step.
        If false, FDV calculations will be averaged over all time steps.    
    
    EACH_NODE: bool
        Flag to determine if calculations are to be performed over each node. 
        If true, FDV calculations will be performed for each node.If false, FDV
        calculations will be averaged over all nodes.
        
    wn: 
        
    Returns 
    -------    
    Not Applicable
    
    Notes
    -----
    
    """      
    if EACH_TIME==True and EACH_NODE==True:
        
        fdv_temp = fdv.unstack().T
        fdv_temp.index = fdv_temp.index.format()
        fdv_temp.plot( legend=False)
        plt.ylim( (-0.05, 1.05) )
        plt.ylabel('FDV for each node and time')
        
        fdd_temp = 100*fdd.sum(level=1)/len(fdd.sum(level=0))
        fdd_temp.index = fdd_temp.index.format()
        plt.figure()
        fdd_temp.plot(legend=False,kind='area',x_compat=True)               
        plt.ylim((0,100))
        plt.ylabel('Percentage of nodes meeting demand')
           
    # FDV for all nodes (averaged over all times)    
    if EACH_TIME==False and EACH_NODE==True:
        fdv_temp = fdv.to_dict()
        wntr.network.draw_graph(wn, node_attribute = fdv_temp, node_size = 40, title = 'FDV over all times', node_range= [0,1])
        
        fdd_temp = fdd.to_dict()
        wntr.network.draw_graph(wn, node_attribute = fdd_temp, node_size = 40, title = 'FDD over all times', node_range = [0,1])
   
   # FDV for all time (averaged over all nodes)        
    if EACH_TIME==True and EACH_NODE==False:
        #FDV
        fdv_temp = fdv
        plt.figure()
        fdv_temp.index = fdv_temp.index.format() 
        fdv_temp.plot(ax=plt.gca(), label='Average', color='k', linewidth=3.0, legend=False)
       
        #FDD
        fdd_temp = fdd
        plt.figure()
        fdd_temp.index = fdd_temp.index.format() 
        fdd_temp.plot(ax=plt.gca(), label='Average', color='k', linewidth=3.0, legend=False)
   
   # FDV for scenario (averaged over all times and nodes)   
    if EACH_TIME==False and EACH_NODE==False:
        print('Overall scenario FDV = '+ str(fdv))
        print('Overall scenario FDD = '+ str(fdd))
    return
       
def adjust_demand(Rd, P, Pstar):
    """Adjust simulated demands based on node pressure
    
    Parameters
    ----------
    Rd : numpy array or scalar
        Requested demand
    
    P : numpy array or scalar
        Pressure

    Pstar : scalar
        Pressure threshold
    
    Returns
    -------
    Ad : numpy array or scalar
        Adjusted demand
    
    Notes
    -----
    Equation 1 in Ostfeld et al, Urban Water, 4, 2002
    
    """
    Ad = Rd
    Ad_temp = (Rd/np.sqrt(Pstar))*np.sqrt(P) 
    Ad[P < Pstar] = Ad_temp[P < Pstar]
    return Ad
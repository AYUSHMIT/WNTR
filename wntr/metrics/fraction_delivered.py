import logging

logger = logging.getLogger('wntr.metrics.fraction_delivered')

def fdv(node_results, average_times=False, average_nodes=False):
    """
    Compute fraction delivered volume (FDV), equations modified from [1]. 
    The metric can be averaged over times and/or nodes.
    
    Parameters
    ----------
    node_results : pd.Panel
        A pandas Panel containing node results. 
        Items axis = attributes, Major axis = times, Minor axis = node names
        FDV uses 'expected demand' and 'demand' attrbutes.
        
    average_times : bool (default = False)
        Flag to determine if calculations are to be averaged over each time
        step. If false, FDV calculations will be performed for each time step.
        If true, FDV calculations will be averaged over all time steps.
    
    average_nodes : bool (default = False)
        Flag to determine if calculations are to be averaged over each node. 
        If false, FDV calculations will be performed for each node. If true, FDV
        calculations will be averaged over all nodes.

    Returns 
    -------    
    fdv : pd.DataFrame, pd.Series, or scalar (depending on node and time averaging)
        Fraction of delivered volume
        
    References
    ----------
    [1] Ostfeld A, Kogan D, Shamir U. (2002). Reliability simulation of water
    distribution systems - single and multiquality, Urban Water, 4, 53-61
    """

    exp_demand = _average_attribute(node_results['expected_demand'], average_times, average_nodes)
    act_received = _average_attribute(node_results['demand'], average_times, average_nodes)

    # Calculate FDV    
    fdv = act_received / exp_demand
    
    # Replace NaNs (generated by nodes with 0 demand) 
    try:
        fdv = fdv.fillna(1) 
    except:
        if exp_demand == 0:
            fdv = 1
    
    return fdv
    
def fdd(node_results, Dstar, average_times=False, average_nodes=False):
    """
    Compute fraction delivered demand (FDD), equations modified from [1]. 
    The metric can be averaged over times and/or nodes.
    
    Parameters
    ----------
    node_results : pd.Panel
        A pandas Panel containing node results. 
        Items axis = attributes, Major axis = times, Minor axis = node names
        FDD uses 'expected demand' and 'demand' attrbutes.
        
    Dstar : float
        Threshold demand factor
        
    average_times : bool (default = False)
        Flag to determine if calculations are to be averaged over each time
        step. If false, FDV calculations will be performed for each time step.
        If true, FDV calculations will be averaged over all time steps.
    
    average_nodes : bool (default = False)
        Flag to determine if calculations are to be averaged over each node. 
        If false, FDV calculations will be performed for each node. If true, FDV
        calculations will be averaged over all nodes.

    Returns 
    -------    
    fdd : pd.DataFrame, pd.Series, or scalar (depending on node and time averaging)
        Fraction of delivered demand
        
    References
    ----------
    [1] Ostfeld A, Kogan D, Shamir U. (2002). Reliability simulation of water
    distribution systems - single and multiquality, Urban Water, 4, 53-61
    """

    fdv_metric = fdv(node_results, average_times, average_nodes)
        
    # Calculate FDD
    fdd = (fdv_metric >= Dstar)+0 
    
    return fdd
    
def fdq(node_results, Qstar, average_times=False, average_nodes=False):
    """
    Compute fraction delivered quality (FDQ), equations modified from [1]. 
    The metric can be averaged over times and/or nodes.
    
    Parameters
    ----------
    node_results : pd.Panel
        A pandas Panel containing node results. 
        Items axis = attributes, Major axis = times, Minor axis = node names
        FDQ uses 'quality' attrbute.
        
    Qstar : float
        Water quality threshold.
        
    average_times : bool (default = False)
        Flag to determine if calculations are to be averaged over each time
        step. If false, FDV calculations will be performed for each time step.
        If true, FDV calculations will be averaged over all time steps.
    
    average_nodes : bool (default = False)
        Flag to determine if calculations are to be averaged over each node. 
        If false, FDV calculations will be performed for each node. If true, FDV
        calculations will be averaged over all nodes.

    Returns 
    -------    
    fdq : pd.DataFrame, pd.Series, or scalar (depending on node and time averaging)
        Fraction of delivered quality
        
    References
    ----------
    [1] Ostfeld A, Kogan D, Shamir U. (2002). Reliability simulation of water
    distribution systems - single and multiquality, Urban Water, 4, 53-61
    """

    quality = _average_attribute(node_results['quality'], average_times, average_nodes)
    
    fdq = (quality >= Qstar)+0 
            
    return fdq
    
def _average_attribute(attribute, average_times, average_nodes):
     # FDV for all times and nodes
    if average_times==False and average_nodes==False:
        pass
        
    # FDV for all nodes (averaged over all times)    
    if average_times==True and average_nodes==False:
        attribute = attribute.sum(axis=0)
        
    # FDV for all time (averaged over all nodes)        
    if average_times==False and average_nodes==True:
        attribute = attribute.sum(axis=1)
       
    # FDV for scenario (averaged over all times and nodes)   
    if average_times==True and average_nodes==True:
        attribute = attribute.sum().sum()
        
    return attribute
    
        
#def fraction_delivered_graph(fdv, fdd, EACH_TIME, EACH_NODE,wn):
#    """
#    Graphs the fraction delivered volume (FDV) and fraction delivered demand 
#    (FDD) based on the their respective formats (i.e. if they were averaged
#    over times or nodes)
#    
#    Parameters
#    ----------
#    fdv: pandas dataframe
#        Calculated FDV from fraction_delivered_metrics.py
#
#    fdd: pandas dataframe
#        Calculated FDD from fraction_delivered_metrics.py
#    
#    EACH_TIME: bool
#        Flag to determine if calculations are to be performed over each time
#        step. If true, FDV calculations will be performed for each time step.
#        If false, FDV calculations will be averaged over all time steps.    
#    
#    EACH_NODE: bool
#        Flag to determine if calculations are to be performed over each node. 
#        If true, FDV calculations will be performed for each node.If false, FDV
#        calculations will be averaged over all nodes.
#        
#    wn: 
#        
#    Returns 
#    -------    
#    Not Applicable
#    
#    Notes
#    -----
#    
#    """      
#    if EACH_TIME==True and EACH_NODE==True:
#        
#        fdv_temp = fdv.unstack().T
#        fdv_temp.index = fdv_temp.index.format()
#        fdv_temp.plot( legend=False)
#        plt.ylim( (-0.05, 1.05) )
#        plt.ylabel('FDV for each node and time')
#        
#        fdd_temp = 100*fdd.sum(axis=1)/len(fdd.sum(axis=0))
#        fdd_temp.index = fdd_temp.index.format()
#        plt.figure()
#        fdd_temp.plot(legend=False,kind='area',x_compat=True)               
#        plt.ylim((0,100))
#        plt.ylabel('Percentage of nodes meeting demand')
#           
#    # FDV for all nodes (averaged over all times)    
#    if EACH_TIME==False and EACH_NODE==True:
#        fdv_temp = fdv.to_dict()
#        wntr.network.draw_graph(wn, node_attribute = fdv_temp, node_size = 40, title = 'FDV over all times', node_range= [0,1])
#        
#        fdd_temp = fdd.to_dict()
#        wntr.network.draw_graph(wn, node_attribute = fdd_temp, node_size = 40, title = 'FDD over all times', node_range = [0,1])
#   
#   # FDV for all time (averaged over all nodes)        
#    if EACH_TIME==True and EACH_NODE==False:
#        #FDV
#        fdv_temp = fdv
#        plt.figure()
#        fdv_temp.index = fdv_temp.index.format() 
#        fdv_temp.plot(ax=plt.gca(), label='Average', color='k', linewidth=3.0, legend=False)
#       
#        #FDD
#        fdd_temp = fdd
#        plt.figure()
#        fdd_temp.index = fdd_temp.index.format() 
#        fdd_temp.plot(ax=plt.gca(), label='Average', color='k', linewidth=3.0, legend=False)
#   
#   # FDV for scenario (averaged over all times and nodes)   
#    if EACH_TIME==False and EACH_NODE==False:
#        print('Overall scenario FDV = '+ str(fdv))
#        print('Overall scenario FDD = '+ str(fdd))
#    return
       